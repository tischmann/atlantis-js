"use strict"; let $$ = function () { const eventHandlers = new Map, atlantis = {}, offEvents = function (HTMLCollection, recursive = !0) { Array.from(HTMLCollection).filter(node => 3 != node.nodeType).forEach((function (node) { atlantis.off(node), recursive && node.children && offEvents(node.children) })) }, mutationObserver = new MutationObserver(mutations => { "removedNodes" in mutations[0] && (offEvents(mutations[0].removedNodes), Array.from(mutations[0].removedNodes).forEach(element => { element = void 0 })) }); return window.onload = function () { mutationObserver.observe(document.body, { childList: !0, subtree: !0 }) }, atlantis.create = function (tagName, attributes = {}) { const element = document.createElement(tagName); return attributes instanceof Object && Object.entries(attributes).forEach(([key, value]) => { if ("class" == key) { if (!value) return; if ("string" == typeof value && (value = value.split(" ")), !(value instanceof Array)) return; return value.forEach(name => element.classList.add(name)) } if ("style" == key) return atlantis.css(element, value); element.setAttribute(key, value) }), element }, atlantis.on = function (element, event, handler, capture = !1) { if (!element) return; const set = eventHandlers.get(event) || new Set; eventHandlers.set(event, set.add({ element: element, handler: handler, capture: capture })), element.addEventListener(event, handler, capture) }, atlantis.off = function (element, event, handler) { if (element) { if (!eventHandlers.has(event)) return !1; loop: for (const [name, set] of eventHandlers) if (!event || name === event) { for (const obj of set) if ((!handler || obj.handler === handler) && (element.removeEventListener(name, obj.handler, obj.capture), set.delete(obj), handler)) break loop; if (event) break } } }, atlantis.fetch = function ({ method: method = "GET", url: url = "/", body: body = {}, success: success = function () { }, failure: failure = function () { }, headers: headers = {} } = {}) { const init = { method: method = method.toUpperCase(), headers: headers }; "POST" == method && (init.body = JSON.stringify(body)), fetch(url, init).then(response => success(response)).catch(error => failure(error)) }, atlantis.camelToDash = function (string) { return string.split(/(?=[A-Z])/).map(value => value.toLowerCase()).join("-") }, atlantis.dashToCamel = function (string) { return string.split("-").map((value, index) => (value = value.toLowerCase(), index ? `${value.charAt(0).toUpperCase()}${value.slice(1)}` : value)).join("") }, atlantis.cookie = function (...args) { const options = { path: "/", secure: !0, samesite: "strict", "max-age": 1209600 }; if (3 == args.length && (options = { ...options, ...args[2] }), 1 == args.length) { args[0] = args[0].replace(/([\.$?*|{}\(\)\[\]\\\/\+^])/g, "\\$1"); const regex = new RegExp(`(?:^|; )${args[0]}=([^;]*)`), matches = document.cookie.match(regex); return matches ? decodeURIComponent(matches[1]) : void 0 } if (2 == args.length) { let cookie = `${encodeURIComponent(args[0])}=${encodeURIComponent(args[1])}`; (options.expires || !1 instanceof Date) && (options.expires = options.expires.toUTCString()), Object.entries(options).forEach(([key, value]) => { !1 === value && (value = ""), cookie += `;${key}=${value}` }), document.cookie = cookie } }, atlantis.datepicker = function (element, { locale: locale = "ru", date: date = new Date, current: current = date, callback: callback = function () { } } = {}) { if ("_datepicker" in element) return element._datepicker; const today = new Date, container = atlantis.create("div", { class: "atlantis-datepicker-container" }), yearsWrapper = atlantis.create("div", { class: "atlantis-datepicker-years-wrapper" }), monthWrapper = atlantis.create("div"); let years, months, monthTable; const labels = { days: [], months: [] }; for (let d = 1; d <= 7; d++)labels.days.push(new Date(2020, 10, d).toLocaleString(locale, { weekday: "short" })); for (let m = 0; m <= 11; m++)labels.months.push(new Date(2021, m, 1).toLocaleString(locale, { month: "long" })); function destroyYears() { years && (years.remove(), years = void 0) } function destroyMonths() { months && (months.remove(), months = void 0) } function getYears() { destroyYears(), years = atlantis.create("select"); for (let year = 2011; year <= today.getFullYear(); year++) { const newDate = new Date(year, date.getMonth(), date.getDate()), option = atlantis.create("option"); year == current.getFullYear() && (option.selected = "selected", option.classList.add("current")), option.value = newDate.toLocaleDateString("en-US"), option.innerHTML = newDate.toLocaleDateString(locale, { year: "numeric" }), years.append(option) } return atlantis.on(years, "change", refreshMonthTable), years } function getMonths() { destroyMonths(), months = atlantis.create("select"); for (let month = 0; month <= 11; month++) { const newDate = new Date(date.getFullYear(), month, date.getDate()), option = atlantis.create("option"); month == current.getMonth() && (option.selected = "selected", option.classList.add("current")), option.value = newDate.toLocaleDateString("en-US"), option.innerHTML = labels.months[month], months.append(option) } return atlantis.on(months, "change", refreshMonthTable), months } function clickHandler(event) { event.stopPropagation() } function refreshMonthTable(event) { date = new Date(Date.parse(this.value)), destroyTable(), monthWrapper.append(getTable()) } function getDaysInMonth(month, year) { return new Date(year, month + 1, 0).getDate() } function getTable() { const year = date.getFullYear(), month = date.getMonth(), days_in_month = getDaysInMonth(month, year), first_day_date = new Date(year, month, 1), first_day_weekday = first_day_date.getDay(), prev_month = 0 == month ? 11 : month - 1, prev_year = 11 == prev_month ? year - 1 : year, prev_days = getDaysInMonth(prev_month, prev_year); monthTable = document.createElement("table"); const thead = document.createElement("thead"); let tr = document.createElement("tr", { class: "week-days" }); for (let d = 1; d <= 7; d++) { const th = document.createElement("th"); th.innerHTML = labels.days[d < 7 ? d : 0], tr.append(th) } thead.append(tr), monthTable.append(thead); let week = 0, next_month_day = 1, day = 1; const tbody = document.createElement("tbody"); for (let i = 1; i < 42; i++) { 0 == week && (tr = document.createElement("tr"), tr.classList.add("week")); const td = document.createElement("td"); if (i < new Date(year, month, 1).getDay()) td.innerHTML = prev_days - first_day_weekday + i + 1, tr.append(td); else if (day > days_in_month) td.innerHTML = next_month_day, tr.append(td), next_month_day++; else { const dayDate = new Date(year, month, day); td.innerHTML = day, day == today.getDate() && today.getMonth() == month && today.getFullYear() == year && td.classList.add("today"), day == date.getDate() && current.getMonth() == month && current.getFullYear() == year && td.classList.add("current"), td.setAttribute("data-time", dayDate.getTime()), atlantis.on(td, "click", callback), tr.append(td), day++ } 6 == week ? (tbody.append(tr), week = 0) : week++ } return monthTable.append(tbody), monthTable } function show(event) { if (event.stopPropagation(), monthTable) return !1; atlantis.on(document, "click", hide), destroyYears(), destroyMonths(), yearsWrapper.append(getMonths()), yearsWrapper.append(getYears()), destroyTable(), monthWrapper.append(getTable()), document.body.append(container), atlantis.on(container, "click", clickHandler); const offset = element.getBoundingClientRect(); container.style.top = `${offset.top + offset.height}px`, container.style.left = `${offset.left}px` } function destroyTable() { monthTable && (monthTable.remove(), monthTable = void 0) } function hide() { destroyTable(), container.remove(), atlantis.off(document, "click", hide) } function destroy() { hide(), container = void 0, atlantis.off(element), delete element._datepicker } return container.append(yearsWrapper), container.append(monthWrapper), atlantis.on(element, "click", show), element._datepicker = { show: show, hide: hide, destroy: destroy }, element._datepicker }, atlantis.draggable = function (element, { parent: parent = element.parentNode, axis: axis = "", drag: drag = function () { }, start: start = function () { }, stop: stop = function () { } } = {}) { if ("_draggable" in element) return element._draggable; let isMouseDown = !1; const diff = { x: 0, y: 0 }; function mouseDown(event) { isMouseDown = !0, diff.x = event.clientX - element.offsetLeft, diff.y = event.clientY - element.offsetTop, start() } function mouseUp() { isMouseDown = !1, stop() } function mouseMove(event) { if (!isMouseDown) return !1; const position = { top: event.clientY - diff.y, left: event.clientX - diff.x }, containment = { right: parent.clientWidth - element.clientWidth, bottom: parent.clientHeight - element.clientHeight }; switch (position.top < 0 ? position.top = 0 : position.top > containment.bottom && (position.top = containment.bottom), position.left < 0 ? position.left = 0 : position.left > containment.right && (position.left = containment.right), axis) { case "x": element.style.left = `${position.left}px`; break; case "y": element.style.top = `${position.top}px`; break; default: element.style.top = `${position.top}px`, element.style.left = `${position.left}px` }drag() } function destroy() { return atlantis.off(document, "mousemove", mouseMove), atlantis.off(element, "mouseup", mouseUp), atlantis.off(element, "mousedown", mouseDown), delete element._draggable, element } function create() { atlantis.on(document, "mousemove", mouseMove), atlantis.on(element, "mouseup", mouseUp), atlantis.on(element, "mousedown", mouseDown) } return create(), element._draggable = { destroy: destroy }, element._draggable }, atlantis.isVisible = function (element) { return element.offsetWidth > 0 || element.offsetHeight > 0 }, atlantis.parent = function (element, selector) { if (selector) for (; ;) { if (!(element = element.parentNode)) return; if (element === document.body) return; if (element.parentNode.querySelector(selector)) return element } }, atlantis.height = function (element) { return parseFloat(getComputedStyle(element).height.replace("px", "")) }, atlantis.width = function (element) { return parseFloat(getComputedStyle(element).width.replace("px", "")) }, atlantis.css = function (element, properties = {}) { properties instanceof Object && Object.entries(properties).forEach(([key, value]) => { element.style[atlantis.dashToCamel(key)] = value }) }, atlantis.unhighlight = function (element) { element.innerHTML = element.innerHTML.replace(/(<span class="highlight">|<\/span>)/gim, "") }, atlantis.highlight = function (element, value = "", callback = function () { }, type = "span", classname = "highlight") { let count = 0; return (value = value.replace(/\\/, "")) ? (element.innerHTML = element.innerHTML.replace(new RegExp(`(${value})`, "gim"), (function (match, p1) { callback(element); const wrapper = atlantis.create(type, { class: classname }); return wrapper.innerHTML = p1, count++, wrapper.outerHTML })), count) : count }, atlantis.count = function (parentNode, selector) { return parentNode.querySelectorAll(selector).length }, atlantis.trigger = function (element, event, data = {}) { let customEvent; return window.CustomEvent && "function" == typeof window.CustomEvent ? customEvent = new CustomEvent(event, { detail: data }) : (customEvent = document.createEvent("CustomEvent"), customEvent.initCustomEvent(event, !0, !0, data)), element.dispatchEvent(customEvent) }, atlantis }();
//# sourceMappingURL=atlantis.min.js.map